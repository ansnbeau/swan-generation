[
  {
    "id": "PIDhard",
    "name": "PIDhard",
    "nl_description": "PID-like controller. Computes the error e = p0 − p1 each cycle. The integrator is **gated** by a deadband: if |e| < p5, it integrates e scaled by a time-constant (c0_module0 in C); otherwise the integral input is 0. The integrator resets when p6 is true. A discrete derivative is computed as (e − e_prev) * p4 / c0_module0 with zero on the first step. The output is r0 = p2*e + p3*integral + derivative. This matches the C code where `reg0` stores e, the integrator context `ctx0` accumulates the gated term `t1`, and `t2` is the derivative contribution.",
    "swan": "node n0 (p0: float32;\n         p1: float32;\n         p2: float32;\n         p3: float32;\n         p4: float32;\n         p5: float32;\n         p6: bool;)\n  returns (r0: float32;)\n{\n  diagram\n    (#1298 expr 0.0)\n    (#1299 expr if #1067 then #1066 else #1065\n      where\n        (#1067 group)\n        (#1066 group)\n        (#1065 group))\n    (#1300 expr #1069 < #1068\n      where\n        (#1069 group)\n        (#1068 group))\n    (#1301 expr p5)\n    (#1302 block Fun0::Abs)\n    (#1303 expr pre #1070\n      where\n        (#1070 group))\n    (#1304 expr 0.0)\n    (#1305 expr #1072 -> #1071\n      where\n        (#1072 group)\n        (#1071 group))\n    (#1306 def r0)\n    (#1311 expr #1078 - #1077\n      where\n        (#1078 group)\n        (#1077 group))\n    (#1312 block {op_expr%(+)%op_expr})\n    (#1322 expr #1090 - #1089\n      where\n        (#1090 group)\n        (#1089 group))\n    (#1323 expr p1)\n    (#1324 expr p0)\n    (#0   expr p6)\n    (#1   block ({op_expr%function x => x / c0%op_expr}))\n    (#2   block ({op_expr%function x => x * p3%op_expr}))\n    (#3   block ({op_expr%function x => x * p4%op_expr}))\n    (#4   block ({op_expr%function x => x * p2%op_expr}))\n    (#5   block (restart (Fun1::Integrator \\ i: 0.0) every #7)\n      where\n        (#7 group))\n    (#8   block ({op_expr%function x => x * c0%op_expr}))\n    (#1325 wire #1323 => #1089)\n    (#1328 wire #1303 => #1077)\n    (#1330 wire #1304 => #1072)\n    (#1331 wire #1305 => #1312 .(3))\n    (#1332 wire #1298 => #1065)\n    (#1339 wire #1312 .(1) => #1306)\n    (#1342 wire #1300 => #1067)\n    (#1346 wire #1324 => #1090)\n    (#1350 wire #1302 => #1069)\n    (#1351 wire #1301 => #1068)\n    (#1352 wire #1322 => #1078, #1070, #1302, #4, #8)\n    (#9   wire #4 => #1312 .(1))\n    (#10  wire #8 => #1066)\n    (#11  wire #5 => #2 .(x))\n    (#12  wire #1311 => #3)\n    (#13  wire #0 => #7)\n    (#14  wire #3 => #1)\n    (#15  wire #2 => #1312 .(2))\n    (#16  wire #1299 => #5 .(x))\n    (#17  wire #1 => #1071)\n}",
    "c_code": "void n0_module0(\n  swan_float32 p0,\n  swan_float32 p1,\n  swan_float32 p2,\n  swan_float32 p3,\n  swan_float32 p4,\n  swan_float32 p5,\n  swan_bool  p6,\n  outC_n0_module0 *outC)\n{\n  swan_float32 t0;\n  swan_float32 t1;\n  swan_float32 t2;\n  swan_float32 t3;\n  swan_float32 l0;\n\n  l0 = outC->reg0;\n  outC->reg0 = p0 - p1;\n  if (p6) {\n    Fun1_reset(&outC->ctx0);\n  }\n  if (swan_lit_float32(0) <= outC->reg0) {\n    t0 = outC->reg0;\n  }\n  else {\n    t0 = - outC->reg0;\n  }\n  if (t0 < p5) {\n    t1 = outC->reg0 * c0_module0;\n  }\n  else {\n    t1 = swan_lit_float32(0.0);\n  }\n  Fun1(&swan_lit_float32(0.0), t1, &outC->ctx0);\n  t3 = outC->ctx0.y;\n  if (outC->ini) {\n    t2 = swan_lit_float32(0.0);\n  }\n  else {\n    t2 = (outC->reg0 - l0) * p4 / c0_module0;\n  }\n  outC->r0 = outC->reg0 * p2 + t3 * p3 + t2;\n  if (outC->ini) {\n    outC->ini = swan_false;\n  }\n}",
    "inline": {
      "language": "swan",
      "line_index": 36,
      "prefix": "node n0 (p0: float32;\n         p1: float32;\n         p2: float32;\n         p3: float32;\n         p4: float32;\n         p5: float32;\n         p6: bool;)\n  returns (r0: float32;)\n{\n  diagram\n    (#1298 expr 0.0)\n    (#1299 expr if #1067 then #1066 else #1065\n      where\n        (#1067 group)\n        (#1066 group)\n        (#1065 group))\n    (#1300 expr #1069 < #1068\n      where\n        (#1069 group)\n        (#1068 group))\n    (#1301 expr p5)\n    (#1302 block Fun0::Abs)\n    (#1303 expr pre #1070\n      where\n        (#1070 group))\n    (#1304 expr 0.0)\n    (#1305 expr #1072 -> #1071\n      where\n        (#1072 group)\n        (#1071 group))\n    (#1306 def r0)\n    (#1311 expr #1078 - #1077\n      where\n        (#1078 group)\n        (#1077 group))\n    (#1312 block {op_expr%(+)%op_expr})",
      "target": "    (#1322 expr #1090 - #1089",
      "suffix": "      where\n        (#1090 group)\n        (#1089 group))\n    (#1323 expr p1)\n    (#1324 expr p0)\n    (#0   expr p6)\n    (#1   block ({op_expr%function x => x / c0%op_expr}))\n    (#2   block ({op_expr%function x => x * p3%op_expr}))\n    (#3   block ({op_expr%function x => x * p4%op_expr}))\n    (#4   block ({op_expr%function x => x * p2%op_expr}))\n    (#5   block (restart (Fun1::Integrator \\ i: 0.0) every #7)\n      where\n        (#7 group))\n    (#8   block ({op_expr%function x => x * c0%op_expr}))\n    (#1325 wire #1323 => #1089)\n    (#1328 wire #1303 => #1077)\n    (#1330 wire #1304 => #1072)\n    (#1331 wire #1305 => #1312 .(3))\n    (#1332 wire #1298 => #1065)\n    (#1339 wire #1312 .(1) => #1306)\n    (#1342 wire #1300 => #1067)\n    (#1346 wire #1324 => #1090)\n    (#1350 wire #1302 => #1069)\n    (#1351 wire #1301 => #1068)\n    (#1352 wire #1322 => #1078, #1070, #1302, #4, #8)\n    (#9   wire #4 => #1312 .(1))\n    (#10  wire #8 => #1066)\n    (#11  wire #5 => #2 .(x))\n    (#12  wire #1311 => #3)\n    (#13  wire #0 => #7)\n    (#14  wire #3 => #1)\n    (#15  wire #2 => #1312 .(2))\n    (#16  wire #1299 => #5 .(x))\n    (#17  wire #1 => #1071)\n}"
    }
  },
  {
    "id": "rotate_right_diag",
    "name": "rotate_right_diag",
    "nl_description": "Array rotation to the right by one position. For an input vector A of length n, produce B where B[0] = A[n−1] and for i≥1, B[i] = A[i−1]. The C implementation specializes n=10 using a rolling register `reg` initialized with A[9] and then assigns B[i] followed by `reg = A[i]` across the loop.",
    "swan": "function rotate_right_diag (A: int32^n;)\n  returns (B: int32^n;)\n{\n  diagram\n    (#0 def B\n    (#1 expr forward\n      <<n>> with [a] = A;\n      diagram\n        (let b = A[n-1] pre a;\n      returns ([b])\n    (#3 wire #1 .(1) => #0\n}",
    "c_code": "void rotate_right_diag_module0(const array_int32_10 *A, array_int32_10 *B)\n{\n  swan_size i1;\n  swan_int32 reg;\n\n  reg = (*A)[swan_lit_int32(9)];\n  for (i1 = 0; i1 < 10; i1++) {\n    (*B)[i1] = reg;\n    reg = (*A)[i1];\n  }\n}",
    "inline": {
      "language": "swan",
      "line_index": 8,
      "prefix": "function rotate_right_diag (A: int32^n;)\n  returns (B: int32^n;)\n{\n  diagram\n    (#0 def B\n    (#1 expr forward\n      <<n>> with [a] = A;\n      diagram",
      "target": "        (let b = A[n-1] pre a;",
      "suffix": "      returns ([b])\n    (#3 wire #1 .(1) => #0\n}"
    }
  },
  {
    "id": "scadePIDhard",
    "name": "scadePIDhard",
    "nl_description": "PID-like controller with anti-windup by gating. Error e = p0 − p1. If |e| < p5, the integral input is e scaled by a time constant (c0 in C); else it is 0. The integrator context `ctx0` can be reset when p6. Derivative term is (e − e_prev) * p4 / c0, with 0 on the first step. Output combines terms: r0 = p2*e + p3*integral + derivative. Variable reuse in C (`t1`) carries the derivative contribution into the sum.",
    "swan": "node n0(\n    p0 : float32;\n    p1 : float32;\n    p2 : float32;\n    p3 : float32;\n    p4 : float32;\n    p5 : float32;\n    p6 : bool)\n  returns (r0 : float32)\nvar\n  v0  : float32;\n  v1  : float32;\n  v2  : float32;\n  v3  : float32;\n  v4  : float32;\n  v5  : float32;\n  v6  : float32;\n  v7  : bool;\n  v8  : float32;\n  v9  : float32;\n  v10 : bool;\n  v11 : float32;\n  v12 : float32;\n  v13 : float32;\n  v14 : float32;\n  v15 : float32;\n  v16 : float32;\n  v17 : float32;\n  v18 : float32;\n  v19 : float32;\n  v20 : float32;\n  v21 : float32;\n  v22 : float32;\n  v23 : float32;\n  v24 : float32;\n  v25 : float32;\nlet\n  v0  = p0;\n  v1  = p1;\n  v2  = v0 #1 - v1;\n  v3  = p2;\n  v4  = p3;\n  v5  = p4;\n  v6  = p5;\n  v7  = p6;\n  v8  = v3 #1 * v2;\n  v9  = #1 math::Abs(v2);\n  v10 = v9 #1 < v6;\n  v11 = v2 #2 * v14;\n  v12 = #1 pre (v2);\n  v13 = v2 #2 - v12;\n  v14 = T_CCYCLE;\n  v15 = #1 if v10 then (v11) else (v16);\n  v16 = zero;\n  v17 = v13 #3 * v5;\n  v18 = v17 #1 / v19;\n  v19 = T_CCYCLE;\n  v20 = (v21) #1 -> (v18);\n  v21 = zero;\n  v22 = (#3 restart #1 Integrator every v7)(v15, v23);\n  v23 = zero;\n  v24 = v22 #4 * v4;\n  v25 = v8 #3 + v24 #3 + v20;\n  r0  = v25;\ntel",
    "c_code": "void n0(inC_n0 *inC, outC_n0 *outC)\n{\n  float32 t0;\n  float32 t1;\n  float32 v2_prev;\n\n  v2_prev = outC->v2;\n  outC->v2 = inC->p0 - inC->p1;\n  if (inC->p6) {\n    Integrator_reset(&outC->ctx0);\n  }\n  if (swan_lit_float32(0.0) <= outC->v2) {\n    t1 = outC->v2;\n  }\n  else {\n    t1 = -outC->v2;\n  }\n  if (t1 < inC->p5) {\n    t0 = outC->v2 * c0;\n  }\n  else {\n    t0 = zero;\n  }\n  Integrator(t0, zero, &outC->ctx0);\n  if (outC->flag) {\n    outC->flag = swan_false;\n    t1 = zero;\n  }\n  else {\n    t1 = (outC->v2 - v2_prev) * inC->p4 / c0;\n  }\n  outC->r0 = inC->p2 * outC->v2\n           + outC->ctx0.y * inC->p3\n           + t1;\n}",
    "inline": {
      "language": "swan",
      "line_index": 50,
      "prefix": "node n0(\n    p0 : float32;\n    p1 : float32;\n    p2 : float32;\n    p3 : float32;\n    p4 : float32;\n    p5 : float32;\n    p6 : bool)\n  returns (r0 : float32)\nvar\n  v0  : float32;\n  v1  : float32;\n  v2  : float32;\n  v3  : float32;\n  v4  : float32;\n  v5  : float32;\n  v6  : float32;\n  v7  : bool;\n  v8  : float32;\n  v9  : float32;\n  v10 : bool;\n  v11 : float32;\n  v12 : float32;\n  v13 : float32;\n  v14 : float32;\n  v15 : float32;\n  v16 : float32;\n  v17 : float32;\n  v18 : float32;\n  v19 : float32;\n  v20 : float32;\n  v21 : float32;\n  v22 : float32;\n  v23 : float32;\n  v24 : float32;\n  v25 : float32;\nlet\n  v0  = p0;\n  v1  = p1;\n  v2  = v0 #1 - v1;\n  v3  = p2;\n  v4  = p3;\n  v5  = p4;\n  v6  = p5;\n  v7  = p6;\n  v8  = v3 #1 * v2;\n  v9  = #1 math::Abs(v2);\n  v10 = v9 #1 < v6;\n  v11 = v2 #2 * v14;\n  v12 = #1 pre (v2);",
      "target": "  v13 = v2 #2 - v12;",
      "suffix": "  v14 = T_CCYCLE;\n  v15 = #1 if v10 then (v11) else (v16);\n  v16 = zero;\n  v17 = v13 #3 * v5;\n  v18 = v17 #1 / v19;\n  v19 = T_CCYCLE;\n  v20 = (v21) #1 -> (v18);\n  v21 = zero;\n  v22 = (#3 restart #1 Integrator every v7)(v15, v23);\n  v23 = zero;\n  v24 = v22 #4 * v4;\n  v25 = v8 #3 + v24 #3 + v20;\n  r0  = v25;\ntel"
    }
  },
  {
    "id": "minN20",
    "name": "minN20",
    "nl_description": "Compute the minimum of a 20-element int32 vector. Initialize with x[0] then scan all elements, updating if a smaller value is found. The C code mirrors this with `v` seeded to x[0] and a for-loop over 20 entries.",
    "swan": "function MinN <<N>> (x: 'T^N;)\n          returns (v: 'T;)\n          where 'T numeric\n          v = forward <<N>> with [a] = x;\n          let\n              m = if a < last'm then a else last'm;\n          returns (m : last = x[0]);\n\nfunction MinN20 (x: int32^20;)\n          returns (v: int32;)\n          v = MinN<<20>>(x);",
    "c_code": "swan_int32 MinN_module1_N20_Ti32(const array_int32_20 *x)\n{\n  swan_size i1;\n  swan_int32 tmp1;\n  swan_int32 v;\n\n  tmp1 = (*x)[swan_lit_int64(0)];\n  v = tmp1;\n  for (i1 = 0; i1 < 20; i1++) {\n    if ((*x)[i1] < v) {\n      v = (*x)[i1];\n    }\n  }\n  return v;\n}",
    "inline": {
      "language": "swan",
      "line_index": 6,
      "prefix": "function MinN <<N>> (x: 'T^N;)\n          returns (v: 'T;)\n          where 'T numeric\n          v = forward <<N>> with [a] = x;\n          let\n              m = if a < last'm then a else last'm;",
      "target": "          returns (m : last = x[0]);",
      "suffix": "\nfunction MinN20 (x: int32^20;)\n          returns (v: int32;)\n          v = MinN<<20>>(x);"
    }
  },
  {
    "id": "flowmaxinit",
    "name": "flowmaxinit",
    "nl_description": "Running maximum with initialization. On the first cycle, set `max = curValue`. Afterwards, update `max` to max(previous_max, curValue). The C code uses an `ini` flag to choose between initialization and the normal update, and stores the previous maximum in `reg`.",
    "swan": "node FlowMaxInit (curValue: float32;)\n  returns (max: float32;)\n{\n  diagram\n    (#127 expr #0 -> #1\n      where\n        (#0 group)\n        (#1 group)\n    (#128 expr pre #2\n      where\n        (#2 group)\n    (#129 expr if #3 then #4 else #5\n      where\n        (#3 group)\n        (#4 group)\n        (#5 group)\n    (#130 def max\n    (#131 expr curValue\n    (#132 expr #6 >= #7\n      where\n        (#6 group)\n        (#7 group)\n    (#133 wire #131 => #6, #4, #0\n    (#134 wire #129 => #1\n    (#135 wire #127 => #2, #130\n    (#136 wire #128 => #5, #7\n    (#137 wire #132 => #3\n}}",
    "c_code": "void FlowMaxInit_Thermometer(\n  swan_float32 curValue,\n  outC_FlowMaxInit_Thermometer *outC)\n{\n  if (outC->ini) {\n    outC->max = curValue;\n  }\n  else if (curValue >= outC->reg) {\n    outC->max = curValue;\n  }\n  else {\n    outC->max = outC->reg;\n  }\n  if (outC->ini) {\n    outC->ini = swan_false;\n  }\n  outC->reg = outC->max;\n}}",
    "inline": {
      "language": "swan",
      "line_index": 14,
      "prefix": "node FlowMaxInit (curValue: float32;)\n  returns (max: float32;)\n{\n  diagram\n    (#127 expr #0 -> #1\n      where\n        (#0 group)\n        (#1 group)\n    (#128 expr pre #2\n      where\n        (#2 group)\n    (#129 expr if #3 then #4 else #5\n      where\n        (#3 group)",
      "target": "        (#4 group)",
      "suffix": "        (#5 group)\n    (#130 def max\n    (#131 expr curValue\n    (#132 expr #6 >= #7\n      where\n        (#6 group)\n        (#7 group)\n    (#133 wire #131 => #6, #4, #0\n    (#134 wire #129 => #1\n    (#135 wire #127 => #2, #130\n    (#136 wire #128 => #5, #7\n    (#137 wire #132 => #3\n}}"
    }
  },
  {
    "id": "checkmotorhealth",
    "name": "checkmotorhealth",
    "nl_description": "Three-state automaton for motor health: NOMINAL → ABNORMAL → FAILURE. From NOMINAL, if `isMotorFaulty` becomes true, move to ABNORMAL. From ABNORMAL, return to NOMINAL if `isMotorFaulty` becomes false; otherwise, after a timer of 20 time units, transition to FAILURE. From FAILURE, after 20 time units, transition back to NOMINAL. The C code reflects this with `Times_Flows_ti8(..., 20, ...)` timers per state and explicit state outputs NOMINAL/ABNORMAL/FAILURE.",
    "swan": "node CheckMotorHealth (isMotorFaulty: bool;)\n  returns (motorHealthState: T::MotorHealth;)\n{\n  diagram\n    (automaton $MotorHealthManagement\n      initial state #1160 Nominal\n        diagram\n          (let motorHealthState = T::NOMINAL;\n      state #1159 Abnormal\n        diagram\n          (let motorHealthState = T::ABNORMAL;\n      state #1161 Failure\n        diagram\n          (let motorHealthState = T::FAILURE;\n      :1: #1160 unless if (isMotorFaulty)\n      restart #1159\n      :1: #1159 unless if (not isMotorFaulty)\n      restart #1160\n      :2: #1159 unless if (Flows::Times(TIME_TO_MOTORS_FAILURE, true))\n      restart #1161\n      :1: #1161 unless if ((restart Flows::Times every isMotorFaulty)\n                             (TIME_TO_MOTORS_NORMAL, true))\n      restart #1160\n}",
    "c_code": "void CheckMotorHealth_QuadFlightControl(\n  swan_bool isMotorFaulty,\n  outC_CheckMotorHealth_QuadFlightControl *outC)\n{\n  SSM_ST_MotorHealthManagement state_sel_MotorHealthManagement;\n  SSM_ST_MotorHealthManagement state_act_MotorHealthManagement;\n  swan_bool guard1;\n  swan_bool guard2;\n  swan_bool guard3;\n\n  state_sel_MotorHealthManagement = outC->reg1;\n  switch (state_sel_MotorHealthManagement) {\n    case SSM_st_Failure_MotorHealthManagement :\n      if (outC->reg) {\n        Times_reset_Flows_ti8(&outC->Ctx_Times2);\n      }\n      if (isMotorFaulty) {\n        Times_reset_Flows_ti8(&outC->Ctx_Times2);\n      }\n      Times_Flows_ti8(swan_lit_int8(20), swan_true, &outC->Ctx_Times2);\n      guard3 = outC->Ctx_Times2.out;\n      outC->reg = guard3;\n      if (guard3) {\n        state_act_MotorHealthManagement = SSM_st_Nominal_MotorHealthManagement;\n      }\n      else {\n        state_act_MotorHealthManagement = SSM_st_Failure_MotorHealthManagement;\n      }\n      break;\n    case SSM_st_Abnormal_MotorHealthManagement :\n      guard2 = !isMotorFaulty;\n      if (outC->reg) {\n        Times_reset_Flows_ti8(&outC->Ctx_Times1);\n      }\n      Times_Flows_ti8(swan_lit_int8(20), swan_true, &outC->Ctx_Times1);\n      guard1 = outC->Ctx_Times1.out;\n      outC->reg = guard2 | guard1;\n      if (guard2) {\n        state_act_MotorHealthManagement = SSM_st_Nominal_MotorHealthManagement;\n      }\n      else if (guard1) {\n        state_act_MotorHealthManagement = SSM_st_Failure_MotorHealthManagement;\n      }\n      else {\n        state_act_MotorHealthManagement = SSM_st_Abnormal_MotorHealthManagement;\n      }\n      break;\n    case SSM_st_Nominal_MotorHealthManagement :\n      outC->reg = isMotorFaulty;\n      if (isMotorFaulty) {\n        state_act_MotorHealthManagement = SSM_st_Abnormal_MotorHealthManagement;\n      }\n      else {\n        state_act_MotorHealthManagement = SSM_st_Nominal_MotorHealthManagement;\n      }\n      break;\n    default :\n      break;\n  }\n  switch (state_act_MotorHealthManagement) {\n    case SSM_st_Failure_MotorHealthManagement :\n      outC->reg1 = SSM_st_Failure_MotorHealthManagement;\n      outC->motorHealthState = FAILURE;\n      break;\n    case SSM_st_Abnormal_MotorHealthManagement :\n      outC->reg1 = SSM_st_Abnormal_MotorHealthManagement;\n      outC->motorHealthState = ABNORMAL;\n      break;\n    case SSM_st_Nominal_MotorHealthManagement :\n      outC->reg1 = SSM_st_Nominal_MotorHealthManagement;\n      outC->motorHealthState = NOMINAL;\n      break;\n    default :\n      /* this default branch is unreachable */\n      break;\n  }\n}",
    "inline": {
      "language": "swan",
      "line_index": 10,
      "prefix": "node CheckMotorHealth (isMotorFaulty: bool;)\n  returns (motorHealthState: T::MotorHealth;)\n{\n  diagram\n    (automaton $MotorHealthManagement\n      initial state #1160 Nominal\n        diagram\n          (let motorHealthState = T::NOMINAL;\n      state #1159 Abnormal\n        diagram",
      "target": "          (let motorHealthState = T::ABNORMAL;",
      "suffix": "      state #1161 Failure\n        diagram\n          (let motorHealthState = T::FAILURE;\n      :1: #1160 unless if (isMotorFaulty)\n      restart #1159\n      :1: #1159 unless if (not isMotorFaulty)\n      restart #1160\n      :2: #1159 unless if (Flows::Times(TIME_TO_MOTORS_FAILURE, true))\n      restart #1161\n      :1: #1161 unless if ((restart Flows::Times every isMotorFaulty)\n                             (TIME_TO_MOTORS_NORMAL, true))\n      restart #1160\n}"
    }
  }
]